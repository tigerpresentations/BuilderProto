<!DOCTYPE html>
<html>
<head>
    <title>Asset Surface Detection</title>
    <style>
        body { margin: 0; padding: 10px; font-family: Arial; display: flex; }
        .viewer { flex: 1; position: relative; }
        .sidebar { width: 300px; padding: 20px; background: #f5f5f5; }
        #dropZone { 
            width: 100%; height: 500px; border: 2px dashed #ccc; 
            display: flex; align-items: center; justify-content: center;
            background: #fafafa; cursor: pointer;
        }
        #dropZone.dragover { border-color: #007bff; background: #e7f3ff; }
        .surface-item { 
            padding: 10px; margin: 5px 0; border: 1px solid #ddd; 
            border-radius: 4px; cursor: pointer; background: white;
        }
        .surface-item.selected { border-color: #007bff; background: #e7f3ff; }
        .surface-item h4 { margin: 0 0 5px 0; }
        .surface-item p { margin: 2px 0; font-size: 12px; color: #666; }
    </style>
</head>
<body>
    <div class="viewer">
        <div id="dropZone">
            <p>Drag and drop a GLB/GLTF file here</p>
        </div>
    </div>
    
    <div class="sidebar">
        <h3>Detected Surfaces</h3>
        <div id="surfaceList"></div>
    </div>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/loaders/GLTFLoader.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/controls/OrbitControls.js"></script>
    <script>
        const scene = new THREE.Scene();
        const camera = new THREE.PerspectiveCamera(75, 1, 0.1, 1000);
        const renderer = new THREE.WebGLRenderer();
        const controls = new THREE.OrbitControls(camera, renderer.domElement);
        const loader = new THREE.GLTFLoader();
        const raycaster = new THREE.Raycaster();
        const mouse = new THREE.Vector2();
        
        let model = null;
        let surfaces = [];
        let wireframes = [];
        let selectedSurface = null;
        
        const dropZone = document.getElementById('dropZone');
        const surfaceList = document.getElementById('surfaceList');
        
        dropZone.addEventListener('dragover', (e) => {
            e.preventDefault();
            dropZone.classList.add('dragover');
        });
        
        dropZone.addEventListener('dragleave', () => {
            dropZone.classList.remove('dragover');
        });
        
        dropZone.addEventListener('drop', (e) => {
            e.preventDefault();
            dropZone.classList.remove('dragover');
            
            const files = e.dataTransfer.files;
            if (files.length > 0) {
                loadModel(files[0]);
            }
        });
        
        function loadModel(file) {
            const url = URL.createObjectURL(file);
            
            loader.load(url, (gltf) => {
                if (model) {
                    scene.remove(model);
                    clearWireframes();
                }
                
                model = gltf.scene;
                scene.add(model);
                
                const box = new THREE.Box3().setFromObject(model);
                const center = box.getCenter(new THREE.Vector3());
                const size = box.getSize(new THREE.Vector3());
                
                model.position.sub(center);
                camera.position.set(size.x, size.y, size.z * 2);
                controls.target.set(0, 0, 0);
                controls.update();
                
                detectSurfaces();
                URL.revokeObjectURL(url);
                
                setupRenderer();
            });
        }
        
        function setupRenderer() {
            dropZone.innerHTML = '';
            dropZone.appendChild(renderer.domElement);
            
            const rect = dropZone.getBoundingClientRect();
            renderer.setSize(rect.width, rect.height);
            camera.aspect = rect.width / rect.height;
            camera.updateProjectionMatrix();
            
            renderer.domElement.addEventListener('click', onModelClick);
            animate();
        }
        
        function detectSurfaces() {
            surfaces = [];
            clearWireframes();
            
            model.traverse((child) => {
                if (child.isMesh && child.material) {
                    const material = child.material;
                    const materialName = material.name || 'Unnamed';
                    
                    if (materialName.toLowerCase().includes('surface') || 
                        materialName.toLowerCase().includes('panel') ||
                        materialName.toLowerCase().includes('image')) {
                        
                        const geometry = child.geometry;
                        const surfaceArea = calculateSurfaceArea(geometry);
                        const hasUV = geometry.attributes.uv ? 'Yes' : 'No';
                        
                        const surface = {
                            mesh: child,
                            material: material,
                            name: materialName,
                            area: surfaceArea.toFixed(2),
                            uvMapping: hasUV,
                            type: materialName.toLowerCase().includes('image') ? 'image' : 'surface'
                        };
                        
                        surfaces.push(surface);
                        createWireframe(child, surface.type);
                    }
                }
            });
            
            updateSurfaceList();
        }
        
        function calculateSurfaceArea(geometry) {
            if (!geometry.index) return 0;
            
            const position = geometry.attributes.position;
            const index = geometry.index;
            let area = 0;
            
            const v1 = new THREE.Vector3();
            const v2 = new THREE.Vector3();
            const v3 = new THREE.Vector3();
            
            for (let i = 0; i < index.count; i += 3) {
                v1.fromBufferAttribute(position, index.getX(i));
                v2.fromBufferAttribute(position, index.getX(i + 1));
                v3.fromBufferAttribute(position, index.getX(i + 2));
                
                area += new THREE.Triangle(v1, v2, v3).getArea();
            }
            
            return area;
        }
        
        function createWireframe(mesh, type = 'surface') {
            const wireframeGeometry = new THREE.WireframeGeometry(mesh.geometry);
            const color = type === 'image' ? 0xff8c00 : 0x00ff00; // Orange for image, green for surface
            const wireframeMaterial = new THREE.LineBasicMaterial({ 
                color: color, 
                transparent: true, 
                opacity: 0.6 
            });
            const wireframe = new THREE.LineSegments(wireframeGeometry, wireframeMaterial);
            
            wireframe.position.copy(mesh.position);
            wireframe.rotation.copy(mesh.rotation);
            wireframe.scale.copy(mesh.scale);
            wireframe.userData.surface = surfaces.length;
            
            scene.add(wireframe);
            wireframes.push(wireframe);
        }
        
        function clearWireframes() {
            wireframes.forEach(wireframe => scene.remove(wireframe));
            wireframes = [];
        }
        
        function updateSurfaceList() {
            surfaceList.innerHTML = '';
            
            surfaces.forEach((surface, index) => {
                const item = document.createElement('div');
                item.className = 'surface-item';
                item.innerHTML = `
                    <h4>${surface.name}</h4>
                    <p>Area: ${surface.area} unitsÂ²</p>
                    <p>UV Mapping: ${surface.uvMapping}</p>
                `;
                
                item.addEventListener('click', () => selectSurface(index));
                surfaceList.appendChild(item);
            });
        }
        
        function selectSurface(index) {
            selectedSurface = index;
            
            document.querySelectorAll('.surface-item').forEach((item, i) => {
                item.classList.toggle('selected', i === index);
            });
            
            wireframes.forEach((wireframe, i) => {
                if (i === index) {
                    wireframe.material.color.setHex(0xff0000); // Red when selected
                    wireframe.material.opacity = 0.8;
                } else {
                    const surface = surfaces[i];
                    const defaultColor = surface.type === 'image' ? 0xff8c00 : 0x00ff00; // Orange for image, green for surface
                    wireframe.material.color.setHex(defaultColor);
                    wireframe.material.opacity = 0.6;
                }
            });
        }
        
        function onModelClick(event) {
            const rect = renderer.domElement.getBoundingClientRect();
            mouse.x = ((event.clientX - rect.left) / rect.width) * 2 - 1;
            mouse.y = -((event.clientY - rect.top) / rect.height) * 2 + 1;
            
            raycaster.setFromCamera(mouse, camera);
            
            const meshes = surfaces.map(s => s.mesh);
            const intersects = raycaster.intersectObjects(meshes);
            
            if (intersects.length > 0) {
                const clickedMesh = intersects[0].object;
                const surfaceIndex = surfaces.findIndex(s => s.mesh === clickedMesh);
                if (surfaceIndex !== -1) {
                    selectSurface(surfaceIndex);
                }
            }
        }
        
        function animate() {
            requestAnimationFrame(animate);
            controls.update();
            renderer.render(scene, camera);
        }
        
        scene.add(new THREE.AmbientLight(0x404040, 0.6));
        scene.add(new THREE.DirectionalLight(0xffffff, 0.8));
    </script>
</body>
</html>