<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>GLB Surface Inspector</title>
    <style>
        body { margin: 0; font-family: monospace; display: flex; overflow: hidden; }
        #drop-zone { position: absolute; inset: 0; display: flex; align-items: center; justify-content: center; 
                      background: rgba(0,0,0,0.9); color: white; font-size: 24px; z-index: 100; }
        #drop-zone.dragging { background: rgba(0,100,0,0.9); }
        #drop-zone.hidden { display: none; }
        #info-panel { position: absolute; top: 10px; left: 10px; background: rgba(0,0,0,0.8); color: white; 
                      padding: 10px; max-width: 400px; max-height: 90vh; overflow-y: auto; }
        .surface-item { padding: 5px; margin: 5px 0; border: 1px solid #444; cursor: pointer; }
        .surface-item:hover { background: rgba(255,255,255,0.1); }
        .surface-item.selected { background: rgba(255,136,0,0.3); border-color: #ff8800; }
        .surface-name { font-weight: bold; color: #ff8800; }
        .surface-info { font-size: 11px; color: #aaa; }
    </style>
</head>
<body>
    <div id="drop-zone">Drag & Drop GLB/GLTF File</div>
    <div id="info-panel" style="display:none;">
        <h3>Detected Surfaces</h3>
        <div id="surface-list"></div>
    </div>

    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/build/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/loaders/GLTFLoader.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/controls/OrbitControls.js"></script>
    <script>
        // Scene setup
        const scene = new THREE.Scene();
        scene.background = new THREE.Color(0x1a1a1a);
        
        const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
        camera.position.set(5, 5, 5);
        
        const renderer = new THREE.WebGLRenderer({ antialias: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.setPixelRatio(window.devicePixelRatio);
        document.body.appendChild(renderer.domElement);
        
        const controls = new THREE.OrbitControls(camera, renderer.domElement);
        controls.enableDamping = true;
        controls.dampingFactor = 0.05;
        
        // Lighting
        const ambientLight = new THREE.AmbientLight(0xffffff, 0.6);
        scene.add(ambientLight);
        const directionalLight = new THREE.DirectionalLight(0xffffff, 0.4);
        directionalLight.position.set(5, 10, 5);
        scene.add(directionalLight);
        
        // GLB loader
        const loader = new THREE.GLTFLoader();
        const raycaster = new THREE.Raycaster();
        const mouse = new THREE.Vector2();
        
        let loadedModel = null;
        let editableSurfaces = [];
        let wireframes = [];
        let selectedMesh = null;
        
        // Calculate surface area
        function calculateSurfaceArea(geometry) {
            const positions = geometry.attributes.position;
            const indices = geometry.index;
            let area = 0;
            
            if (indices) {
                for (let i = 0; i < indices.count; i += 3) {
                    const a = new THREE.Vector3().fromBufferAttribute(positions, indices.array[i]);
                    const b = new THREE.Vector3().fromBufferAttribute(positions, indices.array[i + 1]);
                    const c = new THREE.Vector3().fromBufferAttribute(positions, indices.array[i + 2]);
                    const ab = b.clone().sub(a);
                    const ac = c.clone().sub(a);
                    area += ab.cross(ac).length() * 0.5;
                }
            }
            return area.toFixed(3);
        }
        
        // Create wireframe overlay
        function createWireframe(mesh, color = 0xff8800) {
            const edges = new THREE.EdgesGeometry(mesh.geometry);
            const wireframe = new THREE.LineSegments(edges, 
                new THREE.LineBasicMaterial({ color: color, linewidth: 2 }));
            wireframe.position.copy(mesh.position);
            wireframe.rotation.copy(mesh.rotation);
            wireframe.scale.copy(mesh.scale);
            wireframe.visible = true;
            mesh.parent.add(wireframe);
            return wireframe;
        }
        
        // Process loaded GLB
        function processModel(gltf) {
            // Clear previous model
            if (loadedModel) {
                scene.remove(loadedModel);
                wireframes.forEach(w => w.parent?.remove(w));
                wireframes = [];
            }
            
            loadedModel = gltf.scene;
            scene.add(loadedModel);
            
            // Scan for editable surfaces
            editableSurfaces = [];
            const surfaceList = document.getElementById('surface-list');
            surfaceList.innerHTML = '';
            
            gltf.scene.traverse((child) => {
                if (child.isMesh && child.material) {
                    const matName = child.material.name || 'Unnamed';
                    const lowerName = matName.toLowerCase();
                    
                    if (lowerName.includes('image') || lowerName.includes('backer')) {
                        // Found editable surface
                        const surfaceData = {
                            mesh: child,
                            material: child.material,
                            name: matName,
                            area: calculateSurfaceArea(child.geometry),
                            hasUV: child.geometry.attributes.uv !== undefined
                        };
                        editableSurfaces.push(surfaceData);
                        
                        // Create wireframe highlight
                        const wireframe = createWireframe(child, lowerName.includes('image') ? 0xff8800 : 0x00ff88);
                        wireframes.push(wireframe);
                        surfaceData.wireframe = wireframe;
                        
                        // Add to UI list
                        const item = document.createElement('div');
                        item.className = 'surface-item';
                        item.dataset.index = editableSurfaces.length - 1;
                        item.innerHTML = `
                            <div class="surface-name">${matName}</div>
                            <div class="surface-info">
                                Area: ${surfaceData.area} | UV: ${surfaceData.hasUV ? 'Yes' : 'No'} | 
                                Type: ${lowerName.includes('image') ? 'Image' : 'Backer'}
                            </div>
                        `;
                        item.addEventListener('click', () => selectSurface(parseInt(item.dataset.index)));
                        surfaceList.appendChild(item);
                    }
                }
            });
            
            // Fit camera to model
            const box = new THREE.Box3().setFromObject(loadedModel);
            const center = box.getCenter(new THREE.Vector3());
            const size = box.getSize(new THREE.Vector3());
            const maxDim = Math.max(size.x, size.y, size.z);
            camera.position.set(maxDim * 1.5, maxDim * 1.5, maxDim * 1.5);
            camera.lookAt(center);
            controls.target.copy(center);
            controls.update();
            
            document.getElementById('info-panel').style.display = editableSurfaces.length > 0 ? 'block' : 'none';
        }
        
        // Surface selection
        function selectSurface(index) {
            const items = document.querySelectorAll('.surface-item');
            items.forEach(item => item.classList.remove('selected'));
            
            if (index >= 0 && index < editableSurfaces.length) {
                items[index].classList.add('selected');
                selectedMesh = editableSurfaces[index].mesh;
                
                // Pulse wireframe for feedback
                const wireframe = editableSurfaces[index].wireframe;
                wireframe.material.color.setHex(0xffff00);
                setTimeout(() => {
                    const name = editableSurfaces[index].name.toLowerCase();
                    wireframe.material.color.setHex(name.includes('image') ? 0xff8800 : 0x00ff88);
                }, 200);
            }
        }
        
        // Mouse click handler
        renderer.domElement.addEventListener('click', (event) => {
            mouse.x = (event.clientX / window.innerWidth) * 2 - 1;
            mouse.y = -(event.clientY / window.innerHeight) * 2 + 1;
            
            raycaster.setFromCamera(mouse, camera);
            const meshes = editableSurfaces.map(s => s.mesh);
            const intersects = raycaster.intersectObjects(meshes);
            
            if (intersects.length > 0) {
                const clickedMesh = intersects[0].object;
                const index = editableSurfaces.findIndex(s => s.mesh === clickedMesh);
                selectSurface(index);
            }
        });
        
        // Drag and drop
        const dropZone = document.getElementById('drop-zone');
        
        ['dragenter', 'dragover', 'dragleave', 'drop'].forEach(eventName => {
            document.addEventListener(eventName, (e) => { e.preventDefault(); e.stopPropagation(); });
        });
        
        document.addEventListener('dragenter', () => dropZone.classList.add('dragging'));
        document.addEventListener('dragleave', () => dropZone.classList.remove('dragging'));
        
        document.addEventListener('drop', (e) => {
            dropZone.classList.remove('dragging');
            const file = e.dataTransfer.files[0];
            if (file && (file.name.endsWith('.glb') || file.name.endsWith('.gltf'))) {
                dropZone.classList.add('hidden');
                const reader = new FileReader();
                reader.onload = (e) => {
                    loader.parse(e.target.result, '', processModel, (error) => console.error(error));
                };
                reader.readAsArrayBuffer(file);
            }
        });
        
        // Animation loop
        function animate() {
            requestAnimationFrame(animate);
            controls.update();
            renderer.render(scene, camera);
        }
        
        // Handle resize
        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        });
        
        animate();
    </script>
</body>
</html>