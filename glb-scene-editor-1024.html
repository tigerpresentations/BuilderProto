<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>GLB Scene Editor - High Resolution</title>
    <style>
        body { margin: 0; font-family: monospace; overflow: hidden; }
        #drop-zone { position: absolute; inset: 0; display: flex; align-items: center; justify-content: center; 
                      background: rgba(0,0,0,0.9); color: white; font-size: 24px; z-index: 100; }
        #drop-zone.dragging { background: rgba(0,100,0,0.9); }
        #drop-zone.hidden { display: none; }
        #controls { position: absolute; top: 10px; left: 10px; background: rgba(0,0,0,0.8); 
                    padding: 15px; border-radius: 5px; color: white; min-width: 250px; }
        button { margin: 5px; padding: 8px 12px; cursor: pointer; background: #4a90e2; 
                 color: white; border: none; border-radius: 3px; }
        button:hover { background: #357abd; }
        #canvas-editor { position: absolute; top: 10px; right: 10px; background: rgba(0,0,0,0.8);
                         padding: 15px; border-radius: 5px; color: white; display: none; }
        #drawing-canvas { border: 2px solid #333; cursor: crosshair; background: white; }
        .quality-info { font-size: 10px; color: #888; margin-top: 5px; }
        #canvas-controls { margin-top: 10px; }
        input[type="color"] { width: 40px; height: 25px; margin: 5px; }
        input[type="file"] { margin: 5px 0; }
        #model-controls { margin-top: 15px; border-top: 1px solid #444; padding-top: 15px; display: none; }
        .control-group { margin: 10px 0; }
        .control-group label { display: block; font-size: 11px; margin-bottom: 3px; }
        input[type="range"] { width: 100%; }
        input[type="checkbox"] { margin-right: 8px; }
        #status { margin-top: 10px; font-size: 12px; color: #0f0; }
        #performance-info { font-size: 10px; color: #888; margin-top: 5px; }
    </style>
</head>
<body>
    <div id="drop-zone">Drag & Drop GLB File</div>
    
    <div id="controls">
        <h3>GLB Scene Editor</h3>
        <div class="control-group">
            <label>Background Color:</label>
            <input type="color" id="bg-color" value="#cccccc">
        </div>
        <button id="clear-model-btn" style="display:none;">Remove Model</button>
        <div id="status">Drop a GLB file to begin</div>
        <div id="performance-info">Performance: Ready</div>
        
        <div id="model-controls">
            <h4>Model Controls</h4>
            <div class="control-group">
                <label>Position X: <span id="pos-x-val">0</span></label>
                <input type="range" id="pos-x" min="-10" max="10" step="0.1" value="0">
                <label>Position Z: <span id="pos-z-val">0</span></label>
                <input type="range" id="pos-z" min="-10" max="10" step="0.1" value="0">
            </div>
            <div class="control-group">
                <label>Scale: <span id="scale-val">1.0</span></label>
                <input type="range" id="scale" min="0.1" max="5" step="0.1" value="1">
            </div>
            <div class="control-group">
                <label>Rotation Y: <span id="rot-y-val">0Â°</span></label>
                <input type="range" id="rot-y" min="0" max="360" step="5" value="0">
            </div>
            <div class="control-group">
                <label>
                    <input type="checkbox" id="backlight-toggle"> Backlight
                </label>
            </div>
            <button id="toggle-canvas-btn">Show Canvas Editor</button>
        </div>
    </div>
    
    <div id="canvas-editor">
        <h4>High-Resolution Texture Editor</h4>
        <canvas id="drawing-canvas" width="1024" height="1024"></canvas>
        <div id="canvas-controls">
            <input type="color" id="brush-color" value="#ff0000" title="Brush Color">
            <input type="file" id="image-upload" accept="image/*" title="Upload Image">
            <button id="clear-canvas-btn">Clear</button>
            <button id="hide-canvas-btn">Hide</button>
        </div>
        <div style="font-size: 11px; color: #aaa; margin-top: 10px;">
            Draw or upload images to texture "Image" materials
        </div>
        <div class="quality-info" id="quality-info">Resolution: 1024x1024 (High Quality)</div>
    </div>

    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/build/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/loaders/GLTFLoader.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/controls/OrbitControls.js"></script>
    <script>
        // Scene setup
        const scene = new THREE.Scene();
        scene.background = new THREE.Color(0xcccccc);
        
        const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
        camera.position.set(5, 5, 5);
        
        const renderer = new THREE.WebGLRenderer({ antialias: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.setPixelRatio(window.devicePixelRatio);
        renderer.shadowMap.enabled = true;
        renderer.shadowMap.type = THREE.PCFSoftShadowMap;
        document.body.appendChild(renderer.domElement);
        
        const controls = new THREE.OrbitControls(camera, renderer.domElement);
        controls.enableDamping = true;
        controls.dampingFactor = 0.05;
        controls.maxPolarAngle = Math.PI * 0.8;
        
        // Lighting
        const ambientLight = new THREE.AmbientLight(0xffffff, 0.6);
        scene.add(ambientLight);
        
        const directionalLight = new THREE.DirectionalLight(0xffffff, 0.8);
        directionalLight.position.set(10, 10, 5);
        directionalLight.castShadow = true;
        directionalLight.shadow.mapSize.setScalar(2048);
        scene.add(directionalLight);
        
        // Floor plane
        const floorGeometry = new THREE.PlaneGeometry(20, 20);
        const floorMaterial = new THREE.MeshStandardMaterial({ 
            color: 0x808080, 
            roughness: 0.8,
            metalness: 0.1 
        });
        const floor = new THREE.Mesh(floorGeometry, floorMaterial);
        floor.rotation.x = -Math.PI / 2;
        floor.position.y = -0.01;
        floor.receiveShadow = true;
        scene.add(floor);
        
        // GLB loader and canvas setup
        const loader = new THREE.GLTFLoader();
        let currentModel = null;
        let imageMaterials = [];
        let canvasTexture = null;
        
        // High-resolution canvas setup optimized for 1024x1024
        const canvas = document.getElementById('drawing-canvas');
        const ctx = canvas.getContext('2d', {
            alpha: false,  // Better performance for opaque textures
            desynchronized: true,  // Reduce input lag
            willReadFrequently: false  // Optimize for drawing
        });
        let isDrawing = false;
        let targetQuality = 1024;
        let currentQuality = 1024;
        let lastTextureUpdate = 0;
        const UPDATE_THROTTLE = 16; // Max 60fps texture updates
        
        // Performance monitoring
        let performanceMonitor = { 
            frameCount: 0, 
            lastTime: performance.now(), 
            averageFPS: 60,
            samples: []
        };
        
        // Advanced device capability detection
        function detectDeviceCapabilities() {
            const gl = renderer.getContext();
            const maxTextureSize = gl.getParameter(gl.MAX_TEXTURE_SIZE);
            const isMobile = /Android|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent);
            const hardwareConcurrency = navigator.hardwareConcurrency || 4;
            
            // Estimate GPU capabilities
            const debugInfo = gl.getExtension('WEBGL_debug_renderer_info');
            const renderer_info = debugInfo ? gl.getParameter(debugInfo.UNMASKED_RENDERER_WEBGL) : 'unknown';
            
            // Conservative memory estimation
            let estimatedVRAM = 512;
            if (renderer_info.includes('GeForce') || renderer_info.includes('Radeon')) {
                estimatedVRAM = 2048;
            } else if (renderer_info.includes('Intel') && !isMobile) {
                estimatedVRAM = 1024;
            }
            
            // Determine if device can handle 1024x1024
            const canHandle1024 = !isMobile && maxTextureSize >= 2048 && estimatedVRAM >= 1024 && hardwareConcurrency >= 4;
            
            return {
                maxTextureSize,
                isMobile,
                hardwareConcurrency,
                estimatedVRAM,
                renderer: renderer_info,
                canHandle1024,
                optimalQuality: canHandle1024 ? 1024 : (isMobile ? 256 : 512)
            };
        }
        
        function initializeCanvas(size = currentQuality) {
            currentQuality = size;
            canvas.width = size;
            canvas.height = size;
            canvas.style.width = '256px';  // Display size stays consistent
            canvas.style.height = '256px';
            
            // Optimized canvas initialization
            ctx.fillStyle = 'white';
            ctx.fillRect(0, 0, size, size);
            ctx.lineWidth = Math.max(4, size / 170); // Optimal brush scaling
            ctx.lineCap = 'round';
            ctx.lineJoin = 'round';
            
            // Enhanced drawing settings
            ctx.imageSmoothingEnabled = true;
            ctx.imageSmoothingQuality = 'high';
            
            // Update info display
            const memoryEstimate = ((size * size * 3) / 1024).toFixed(0); // RGB format
            document.getElementById('quality-info').textContent = 
                `Resolution: ${size}x${size} (${memoryEstimate}KB)`;
        }
        
        function createCanvasTexture() {
            if (canvasTexture) canvasTexture.dispose();
            canvasTexture = new THREE.CanvasTexture(canvas);
            
            // Aggressive optimization for high-resolution
            canvasTexture.format = THREE.RGBFormat; // Save 25% memory
            canvasTexture.flipY = false;
            canvasTexture.magFilter = THREE.LinearFilter;
            canvasTexture.minFilter = THREE.LinearFilter;
            canvasTexture.generateMipmaps = false; // Critical performance save
            canvasTexture.wrapS = THREE.ClampToEdgeWrapping;
            canvasTexture.wrapT = THREE.ClampToEdgeWrapping;
            canvasTexture.unpackAlignment = 1;
            canvasTexture.needsUpdate = true;
            
            return canvasTexture;
        }
        
        function throttledTextureUpdate() {
            const now = performance.now();
            if (now - lastTextureUpdate > UPDATE_THROTTLE) {
                if (canvasTexture) {
                    canvasTexture.needsUpdate = true;
                }
                lastTextureUpdate = now;
            }
        }
        
        function updatePerformanceMonitor() {
            performanceMonitor.frameCount++;
            const currentTime = performance.now();
            
            if (currentTime >= performanceMonitor.lastTime + 1000) {
                const fps = Math.round(
                    (performanceMonitor.frameCount * 1000) / (currentTime - performanceMonitor.lastTime)
                );
                performanceMonitor.averageFPS = fps;
                performanceMonitor.frameCount = 0;
                performanceMonitor.lastTime = currentTime;
                
                // Update performance display
                document.getElementById('performance-info').textContent = 
                    `Performance: ${fps} FPS (${currentQuality}x${currentQuality})`;
                
                // Auto-fallback if severe performance issues
                if (fps < 30 && currentQuality > 512) {
                    console.warn('Performance critical, reducing to 512x512');
                    fallbackToLowerQuality(512);
                } else if (fps < 20 && currentQuality > 256) {
                    console.warn('Performance critical, reducing to 256x256');
                    fallbackToLowerQuality(256);
                }
            }
        }
        
        function fallbackToLowerQuality(newQuality) {
            if (newQuality >= currentQuality) return;
            
            console.log(`Auto-scaling from ${currentQuality}x${currentQuality} to ${newQuality}x${newQuality}`);
            
            const previousImageData = ctx.getImageData(0, 0, currentQuality, currentQuality);
            initializeCanvas(newQuality);
            
            // Scale and preserve content
            if (previousImageData) {
                const tempCanvas = document.createElement('canvas');
                tempCanvas.width = previousImageData.width;
                tempCanvas.height = previousImageData.height;
                const tempCtx = tempCanvas.getContext('2d');
                tempCtx.putImageData(previousImageData, 0, 0);
                
                ctx.drawImage(tempCanvas, 0, 0, currentQuality, currentQuality);
            }
            
            createCanvasTexture();
            
            // Update all materials
            imageMaterials.forEach(material => {
                material.map = canvasTexture;
                material.needsUpdate = true;
            });
        }
        
        function placeModelOnFloor(model) {
            if (currentModel) {
                cleanupModel(currentModel);
                scene.remove(currentModel);
            }
            
            currentModel = model;
            scene.add(model);
            
            // Calculate bounding box for placement
            model.updateMatrixWorld(true);
            const box = new THREE.Box3().setFromObject(model);
            const size = box.getSize(new THREE.Vector3());
            const center = box.getCenter(new THREE.Vector3());
            
            // Center and place on floor
            model.position.x = -center.x;
            model.position.z = -center.z;
            model.position.y = -box.min.y;
            
            // Auto-scale if too large
            const maxDimension = Math.max(size.x, size.y, size.z);
            if (maxDimension > 8) {
                const scale = 8 / maxDimension;
                model.scale.setScalar(scale);
            }
            
            // Find and apply textures to "Image" materials
            imageMaterials = [];
            model.traverse((child) => {
                if (child.isMesh && child.material) {
                    const matName = child.material.name || '';
                    if (matName.toLowerCase().includes('image')) {
                        imageMaterials.push(child.material);
                        child.material.map = canvasTexture;
                        
                        // Initialize backlight properties
                        child.material.emissive = new THREE.Color(0x000000);
                        child.material.emissiveIntensity = 0.0;
                        child.material.emissiveMap = null;
                        
                        child.material.needsUpdate = true;
                    }
                    child.castShadow = true;
                    child.receiveShadow = true;
                }
            });
            
            // Reset backlight toggle
            document.getElementById('backlight-toggle').checked = false;
            
            // Update UI
            document.getElementById('clear-model-btn').style.display = 'block';
            document.getElementById('model-controls').style.display = 'block';
            document.getElementById('status').textContent = 
                `Loaded model (${imageMaterials.length} Image materials found)`;
            
            updateSliders();
            
            // Focus camera
            const modelCenter = new THREE.Vector3();
            box.getCenter(modelCenter);
            modelCenter.y = size.y * 0.5;
            controls.target.copy(modelCenter);
            
            const distance = Math.max(size.x, size.y, size.z) * 2;
            camera.position.set(distance, distance * 0.7, distance);
            controls.update();
        }
        
        function cleanupModel(model) {
            model.traverse((child) => {
                if (child.geometry) child.geometry.dispose();
                if (child.material) {
                    if (child.material.map && child.material.map !== canvasTexture) {
                        child.material.map.dispose();
                    }
                    child.material.dispose();
                }
            });
        }
        
        function updateSliders() {
            if (!currentModel) return;
            
            document.getElementById('pos-x').value = currentModel.position.x;
            document.getElementById('pos-z').value = currentModel.position.z;
            document.getElementById('scale').value = currentModel.scale.x;
            document.getElementById('rot-y').value = (currentModel.rotation.y * 180 / Math.PI) % 360;
            
            updateValueDisplays();
        }
        
        function updateValueDisplays() {
            if (!currentModel) return;
            
            document.getElementById('pos-x-val').textContent = currentModel.position.x.toFixed(1);
            document.getElementById('pos-z-val').textContent = currentModel.position.z.toFixed(1);
            document.getElementById('scale-val').textContent = currentModel.scale.x.toFixed(1);
            document.getElementById('rot-y-val').textContent = Math.round(currentModel.rotation.y * 180 / Math.PI) + 'Â°';
        }
        
        // Drag and drop
        const dropZone = document.getElementById('drop-zone');
        
        ['dragenter', 'dragover', 'dragleave', 'drop'].forEach(eventName => {
            document.addEventListener(eventName, (e) => { e.preventDefault(); e.stopPropagation(); });
        });
        
        document.addEventListener('dragenter', () => dropZone.classList.add('dragging'));
        document.addEventListener('dragleave', () => dropZone.classList.remove('dragging'));
        
        document.addEventListener('drop', (e) => {
            dropZone.classList.remove('dragging');
            const file = e.dataTransfer.files[0];
            if (file && file.name.toLowerCase().endsWith('.glb')) {
                dropZone.classList.add('hidden');
                loadGLBFile(file);
            }
        });
        
        function loadGLBFile(file) {
            const reader = new FileReader();
            reader.onload = (e) => {
                loader.parse(e.target.result, '', (gltf) => {
                    placeModelOnFloor(gltf.scene);
                }, (error) => {
                    console.error('Error loading GLB:', error);
                    document.getElementById('status').textContent = 'Error loading GLB file';
                });
            };
            reader.readAsArrayBuffer(file);
        }
        
        // Canvas drawing events
        canvas.addEventListener('pointerdown', (e) => {
            isDrawing = true;
            ctx.strokeStyle = document.getElementById('brush-color').value;
            ctx.beginPath();
            ctx.moveTo(e.offsetX, e.offsetY);
        });
        
        canvas.addEventListener('pointermove', (e) => {
            if (!isDrawing) return;
            ctx.lineTo(e.offsetX, e.offsetY);
            ctx.stroke();
            throttledTextureUpdate();
        });
        
        canvas.addEventListener('pointerup', () => isDrawing = false);
        canvas.addEventListener('pointerleave', () => isDrawing = false);
        
        // Image upload
        document.getElementById('image-upload').addEventListener('change', (e) => {
            const file = e.target.files[0];
            if (file) {
                const img = new Image();
                img.onload = () => {
                    ctx.fillStyle = 'white';
                    ctx.fillRect(0, 0, currentQuality, currentQuality);
                    
                    const scale = Math.min(currentQuality / img.width, currentQuality / img.height);
                    const width = img.width * scale;
                    const height = img.height * scale;
                    const x = (currentQuality - width) / 2;
                    const y = (currentQuality - height) / 2;
                    
                    ctx.drawImage(img, x, y, width, height);
                    throttledTextureUpdate();
                };
                img.src = URL.createObjectURL(file);
            }
        });
        
        // UI event handlers
        document.getElementById('bg-color').addEventListener('input', (e) => {
            scene.background.setHex(e.target.value.replace('#', '0x'));
        });
        
        document.getElementById('clear-model-btn').addEventListener('click', () => {
            if (currentModel) {
                cleanupModel(currentModel);
                scene.remove(currentModel);
                currentModel = null;
                imageMaterials = [];
                
                document.getElementById('clear-model-btn').style.display = 'none';
                document.getElementById('model-controls').style.display = 'none';
                document.getElementById('backlight-toggle').checked = false;
                document.getElementById('status').textContent = 'Drop a GLB file to begin';
                dropZone.classList.remove('hidden');
            }
        });
        
        document.getElementById('clear-canvas-btn').addEventListener('click', () => {
            ctx.fillStyle = 'white';
            ctx.fillRect(0, 0, currentQuality, currentQuality);
            throttledTextureUpdate();
        });
        
        document.getElementById('toggle-canvas-btn').addEventListener('click', () => {
            const editor = document.getElementById('canvas-editor');
            const isHidden = editor.style.display === 'none' || window.getComputedStyle(editor).display === 'none';
            editor.style.display = isHidden ? 'block' : 'none';
        });
        
        document.getElementById('hide-canvas-btn').addEventListener('click', () => {
            document.getElementById('canvas-editor').style.display = 'none';
        });
        
        // Model control sliders
        ['pos-x', 'pos-z'].forEach((id, index) => {
            document.getElementById(id).addEventListener('input', (e) => {
                if (currentModel) {
                    const coord = index === 0 ? 'x' : 'z';
                    currentModel.position[coord] = parseFloat(e.target.value);
                    updateValueDisplays();
                }
            });
        });
        
        document.getElementById('scale').addEventListener('input', (e) => {
            if (currentModel) {
                const scale = parseFloat(e.target.value);
                currentModel.scale.set(scale, scale, scale);
                updateValueDisplays();
            }
        });
        
        document.getElementById('rot-y').addEventListener('input', (e) => {
            if (currentModel) {
                currentModel.rotation.y = parseFloat(e.target.value) * Math.PI / 180;
                updateValueDisplays();
            }
        });
        
        // Backlight toggle
        document.getElementById('backlight-toggle').addEventListener('change', (e) => {
            const backlightEnabled = e.target.checked;
            
            imageMaterials.forEach(material => {
                if (backlightEnabled) {
                    // Enable backlight glow effect
                    material.emissive = new THREE.Color(0xffffff);
                    material.emissiveIntensity = 0.3;
                    material.emissiveMap = canvasTexture; // Use same texture for glow
                } else {
                    // Disable backlight
                    material.emissive = new THREE.Color(0x000000);
                    material.emissiveIntensity = 0.0;
                    material.emissiveMap = null;
                }
                material.needsUpdate = true;
            });
        });
        
        // Animation loop with performance monitoring
        function animate() {
            requestAnimationFrame(animate);
            controls.update();
            renderer.render(scene, camera);
            updatePerformanceMonitor();
        }
        
        // Handle resize
        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        });
        
        // Initialize with device-optimized settings
        const capabilities = detectDeviceCapabilities();
        console.log('Device capabilities:', capabilities);
        
        // Target 1024x1024 but fallback if needed
        targetQuality = capabilities.canHandle1024 ? 1024 : capabilities.optimalQuality;
        
        console.log(`Initializing with ${targetQuality}x${targetQuality} canvas texture`);
        
        initializeCanvas(targetQuality);
        createCanvasTexture();
        animate();
        
        // Memory monitoring
        if (performance.memory) {
            setInterval(() => {
                const memUsed = (performance.memory.usedJSHeapSize / 1024 / 1024).toFixed(1);
                const memLimit = (performance.memory.totalJSHeapSize / 1024 / 1024).toFixed(1);
                if (memUsed > memLimit * 0.85) {
                    console.warn(`High memory usage: ${memUsed}MB / ${memLimit}MB`);
                }
            }, 10000);
        }
    </script>
</body>
</html>